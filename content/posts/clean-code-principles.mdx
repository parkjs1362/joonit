---
title: "클린 코드 작성 원칙"
description: "가독성 높고 유지보수하기 좋은 클린 코드를 작성하기 위한 핵심 원칙과 실전 예제를 공유합니다."
date: "2025-02-17"
category: "개발"
tags: ["클린코드", "리팩토링", "소프트웨어"]
---

## 클린 코드란?

클린 코드는 읽기 쉽고, 의도가 명확하며, 수정하기 간편한 코드입니다. Robert C. Martin은 "코드를 읽는 시간 대 쓰는 시간의 비율이 10:1"이라고 말했습니다. 결국 잘 읽히는 코드가 좋은 코드입니다.

## 1. 의미 있는 이름 짓기

변수, 함수, 클래스의 이름은 그 역할을 명확히 드러내야 합니다:

```typescript
// 나쁜 예
const d = new Date();
const arr = users.filter(u => u.a > 18);
function calc(x: number, y: number) { return x * y * 0.1; }

// 좋은 예
const currentDate = new Date();
const adultUsers = users.filter(user => user.age > 18);
function calculateTax(price: number, quantity: number) {
  const TAX_RATE = 0.1;
  return price * quantity * TAX_RATE;
}
```

이름 짓기 규칙:
- 축약하지 않기 (`usr` → `user`, `btn` → `button`)
- 의도를 드러내기 (`data` → `userProfile`, `flag` → `isAuthenticated`)
- 일관된 단어 사용 (`get`, `fetch`, `retrieve` 중 하나로 통일)

## 2. 함수는 하나의 일만

함수는 한 가지 일을 잘 수행해야 합니다:

```typescript
// 나쁜 예 - 여러 책임이 섞임
function processUser(user: User) {
  // 유효성 검사
  if (!user.email.includes('@')) throw new Error('Invalid email');
  if (user.name.length < 2) throw new Error('Name too short');

  // DB 저장
  db.users.create(user);

  // 이메일 발송
  sendWelcomeEmail(user.email);

  // 로그 기록
  logger.info(`User created: ${user.email}`);
}

// 좋은 예 - 각 함수가 단일 책임
function validateUser(user: User) {
  if (!user.email.includes('@')) throw new Error('Invalid email');
  if (user.name.length < 2) throw new Error('Name too short');
}

function createUser(user: User) {
  validateUser(user);
  const savedUser = db.users.create(user);
  sendWelcomeEmail(savedUser.email);
  return savedUser;
}
```

## 3. 조기 리턴으로 중첩 줄이기

깊은 중첩은 코드를 읽기 어렵게 만듭니다:

```typescript
// 나쁜 예 - 깊은 중첩
function getDiscount(user: User) {
  if (user) {
    if (user.membership) {
      if (user.membership.type === 'premium') {
        if (user.purchaseCount > 10) {
          return 0.2;
        } else {
          return 0.1;
        }
      } else {
        return 0.05;
      }
    } else {
      return 0;
    }
  } else {
    return 0;
  }
}

// 좋은 예 - 조기 리턴
function getDiscount(user: User) {
  if (!user || !user.membership) return 0;
  if (user.membership.type !== 'premium') return 0.05;
  return user.purchaseCount > 10 ? 0.2 : 0.1;
}
```

## 4. 매직 넘버 제거

의미를 알 수 없는 숫자는 상수로 추출합니다:

```typescript
// 나쁜 예
if (password.length < 8) { /* ... */ }
if (retryCount > 3) { /* ... */ }
const timeout = 5000;

// 좋은 예
const MIN_PASSWORD_LENGTH = 8;
const MAX_RETRY_COUNT = 3;
const REQUEST_TIMEOUT_MS = 5000;

if (password.length < MIN_PASSWORD_LENGTH) { /* ... */ }
if (retryCount > MAX_RETRY_COUNT) { /* ... */ }
```

## 5. 불필요한 주석 제거

코드 자체가 설명이 되도록 작성합니다:

```typescript
// 나쁜 예 - 코드를 반복하는 주석
// 사용자의 나이를 확인한다
if (user.age >= 18) { /* ... */ }

// 좋은 예 - 코드가 의도를 드러냄
const isAdult = user.age >= 18;
if (isAdult) { /* ... */ }

// 좋은 주석 - "왜"를 설명
// 한국 법률 기준 만 18세 이상 성인
const LEGAL_ADULT_AGE = 18;
```

## 6. 일관된 코드 스타일

```typescript
// 프로젝트 전체에서 일관성 유지

// 객체 비구조화 할당 활용
const { name, email, role } = user;

// 배열 메서드 활용
const activeUsers = users
  .filter(user => user.isActive)
  .map(user => user.name);

// 옵셔널 체이닝
const city = user?.address?.city ?? '미입력';
```

## 마무리

클린 코드는 특별한 기술이 아니라 좋은 습관입니다. "동작하는 코드"를 작성한 뒤 반드시 "읽기 좋은 코드"로 다듬는 과정을 거치세요. 처음에는 시간이 더 걸리는 것 같지만, 장기적으로는 디버깅 시간과 유지보수 비용을 크게 절감합니다. 코드는 사람이 읽기 위해 작성하는 것이라는 사실을 항상 기억하세요.
